import os
import cv2
import copy
import datetime
import numpy as np
import matplotlib.pyplot as plt
from libs.util import MaskGenerator
from scipy.ndimage import morphology


def get_sum_int(residual_array):            
    sum_int_diff = []
    for ind in range(len(residual_array)):
        diff_int = np.sum(residual_array[ind])
        sum_int_diff.append(diff_int)
    
    return np.array(sum_int_diff)



def plot_callback(model, save_dir, masked, mask, ori):
    """Called at the end of each epoch, displaying our previous test images,
    as well as their masked predictions and saving them to disk
    model: compiled model
    save_dir: dir to save the figures
    masked: corruped image
    mask: the mask of artifacts
    ori: original image
    the last three arguments are tensors generated by test generator.
    """   
    # Get samples & Display them        
    pred_img = model.predict([masked, mask])
    pred_time = datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')

    # Clear current output and display test images
    for i in range(len(ori)):
        _, axes = plt.subplots(1, 3, figsize=(20, 5))
        axes[0].imshow(masked[i,:,:,:])
        axes[1].imshow(pred_img[i,:,:,:] * 1.)
        axes[2].imshow(ori[i,:,:,:])
        axes[0].set_title('Masked Image')
        axes[1].set_title('Predicted Image')
        axes[2].set_title('Original Image')
        file_name = os.path.join(save_dir, 'img_{}_{}.png'.format(i, pred_time))
        plt.savefig(file_name)
        plt.close()
        
        
        
def corrupt_image(img_array, crop=[512, 512]):
    '''
    Parameters
    ----------
    img_array : array 
        arrays of original images to be inpainted.
    crop : list
        describing the shape of the images to be cropped 
        the default value is [512 512].

    Returns
    -------
    imgs : list
        corrupted image with random mask.
    masks : list
        the raw mask that corrupted the image.
    '''    
    imgs, masks = [], []
    for ind in range(len(img_array)):  
        im = img_array[ind]
        # Create masked array
        mask = MaskGenerator(*crop)
        sample_mask = mask.sample()
        im[sample_mask==0] = 1
        #plt.imshow(im)
        
        # Store for prediction
        imgs.append(im)
        masks.append(sample_mask)
    return imgs, masks

def circular_tumor_mask(orig_mask, rad=3):
    '''
    get the original tumoral mask and fit a circle to the tumor  
    ----------
    orig_mask : array
        tumor mask.
    Returns
    -------
    img : array
        rounded circular mask fitted to the tumor region.
    '''
    height, width, channels = 512,512,3   
    img = np.zeros((height, width, channels), np.uint8)
    
    gray=cv2.cvtColor(orig_mask,cv2.COLOR_BGR2GRAY)
    thresh=cv2.threshold(gray,0,255,cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]
        
    contours,_ = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    areas = [cv2.contourArea(c) for c in contours]
    sorted_areas = np.sort(areas)
    for item in sorted_areas:       
        cnt=contours[areas.index(item)]
        (x1,y1),radius = cv2.minEnclosingCircle(cnt)
        x1 = int(x1)
        y1 = int(y1)
        radius += rad
        radius = int(radius)
        cv2.circle(img,(x1,y1),radius,(1,1,1), -1)    
    return img



def dilate_mask(mask, rad=5):
    '''
    dilating the tumor mask instead of circular region
    ----------
    mask : array
        the binary tumor mask.
    radius : int
        radius of dilation
    Returns
    -------
    temp_dilated : array
        dilated tumor mask.

    '''
    temp = morphology.grey_dilation(mask[:,:,0], (rad,rad))
    temp_dilated = np.repeat(temp[:, :, np.newaxis], 3, axis=2)
    return temp_dilated

def mask_img(img_array, mask_array):
    masked_img = []
    length = img_array.shape[0]
    for ind in range(length):
        
        img = img_array[ind]
        mask = mask_array[ind]
        
        masked_in = copy.deepcopy(img)
        masked_in[mask==1]=1
        masked_img.append(masked_in)
    
    return masked_img





def predict(imgs, masks, model):
    '''
    imgs : list
        corrupted images.
    masks : list
        mask used to corrupt image.
    model : class
        compiled model with weight from phase2 training.

    Returns
    -------
    predictions : list
        prediction of the inpainted images.
    '''
    print('\n'*5)
    print('predicting the images ...')
    print('\n'*5)
    predictions = []
    for ix in range(len(imgs)):
        
        img = imgs[ix]
        mask = masks[ix]
        
        img = np.expand_dims(img, axis=0)
        mask = np.expand_dims(mask, axis=0)
        pred_imgs = np.squeeze(model.predict([img, mask]))
        predictions.append(pred_imgs)       
    return predictions
